<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>clojure.tools.analyzer - tools.analyzer 1.1.2-SNAPSHOT API documentation</title>
    <link rel="icon" href="static/favicon.png" />
    <link rel="shortcut icon" href="static/favicon.png" />
    <link rel="stylesheet" href="static/clojure.css" type="text/css" media="all" />
    <link rel="stylesheet" href="static/wiki.css" type="text/css" media="all" />
    <link rel="stylesheet" href="static/internal.css" type="text/css" media="all" />
    <style>.menuWrapper{height: 36px;}</style>
  </head>
<!--
This document was auto-generated from the source by the clojure autodoc system.
To report errors or ask questions about the overall documentation structure, formatting,
etc., contact Tom Faulhaber (google mail name: tomfaulhaber).
For errors in the documentation of a particular namespace, contact the author of that
namespace.
-->
  <body>
    <div id="AllContentContainer">
      <div id="Header">
	<a href="index.html" id="Logo"><img src="static/clojure-icon.gif" width="100" height="100" alt="Clojure" /></a>
	<h1><a href="index.html" id="page-header" title="page header title">tools.analyzer API Reference</a></h1>
      </div>
      <div id="leftcolumn"><div style="text-align: center;"></div>
<div class="menu">
  <div class="WikiCustomNav WikiElement wiki">
    <span class="toc-header"><span id="project-name">tools.analyzer</span> <span id="version">1.1.2-SNAPSHOT</span> API</span><br />
    <ul>
      <li><a href="index.html" class="wiki_link">Overview</a></li>
      <li><a href="api-index.html" class="wiki_link">API Index</a></li>
    </ul>
    
    
    <a class="wiki_link" href="https://clojure.org">Clojure Home</a>
  </div>
</div>
</div>
      <div id="rightcolumn">
	<div id="Content">
	  <div class="contentBox"><div class="innerContentBox">
              <div class="wiki wikiPage" id="content_view">
                <div id="right-sidebar"><div id="toc">
  <h1 class="nopad">Table of Contents</h1>
  <div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#toc0">Overview</a>
    
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#"></a>
    
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#"></a>
    
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#var-section">Vars and Functions</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer/-parse" class="toc-entry-anchor">-parse</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer/analyze" class="toc-entry-anchor">analyze</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer/analyze-form" class="toc-entry-anchor">analyze-form</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer/analyze-in-env" class="toc-entry-anchor">analyze-in-env</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer/create-var" class="toc-entry-anchor">create-var</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer/empty-env" class="toc-entry-anchor">empty-env</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer/macroexpand" class="toc-entry-anchor">macroexpand</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer/macroexpand-1" class="toc-entry-anchor">macroexpand-1</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer/parse" class="toc-entry-anchor">parse</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer/specials" class="toc-entry-anchor">specials</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer/var?" class="toc-entry-anchor">var?</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#"></a>
    
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.tools.analyzer.ast">clojure.tools.analyzer.ast</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.ast/ast-&gt;eav" class="toc-entry-anchor">ast-&gt;eav</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.ast/children" class="toc-entry-anchor">children</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.ast/children*" class="toc-entry-anchor">children*</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.ast/cycling" class="toc-entry-anchor">cycling</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.ast/nodes" class="toc-entry-anchor">nodes</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.ast/postwalk" class="toc-entry-anchor">postwalk</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.ast/prewalk" class="toc-entry-anchor">prewalk</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.ast/update-children" class="toc-entry-anchor">update-children</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.ast/update-children-reduced" class="toc-entry-anchor">update-children-reduced</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.ast/walk" class="toc-entry-anchor">walk</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.tools.analyzer.ast.query">clojure.tools.analyzer.ast.query</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.ast.query/db" class="toc-entry-anchor">db</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.ast.query/q" class="toc-entry-anchor">q</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.ast.query/query-map" class="toc-entry-anchor">query-map</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.ast.query/resolve-calls" class="toc-entry-anchor">resolve-calls</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.ast.query/unfold-expression-clauses" class="toc-entry-anchor">unfold-expression-clauses</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.tools.analyzer.env">clojure.tools.analyzer.env</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.env/*env*" class="toc-entry-anchor">*env*</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.env/deref-env" class="toc-entry-anchor">deref-env</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.env/ensure" class="toc-entry-anchor">ensure</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.env/with-env" class="toc-entry-anchor">with-env</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.tools.analyzer.passes">clojure.tools.analyzer.passes</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.passes/calculate-deps" class="toc-entry-anchor">calculate-deps</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.passes/desugar-deps" class="toc-entry-anchor">desugar-deps</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.passes/group" class="toc-entry-anchor">group</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.passes/schedule" class="toc-entry-anchor">schedule</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.tools.analyzer.passes.add-binding-atom">clojure.tools.analyzer.passes.add-binding-atom</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.passes.add-binding-atom/add-binding-atom" class="toc-entry-anchor">add-binding-atom</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.tools.analyzer.passes.collect-closed-overs">clojure.tools.analyzer.passes.collect-closed-overs</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.passes.collect-closed-overs/collect-closed-overs" class="toc-entry-anchor">collect-closed-overs</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.tools.analyzer.passes.constant-lifter">clojure.tools.analyzer.passes.constant-lifter</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.passes.constant-lifter/constant-lift" class="toc-entry-anchor">constant-lift</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.tools.analyzer.passes.elide-meta">clojure.tools.analyzer.passes.elide-meta</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.passes.elide-meta/elide-meta" class="toc-entry-anchor">elide-meta</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.passes.elide-meta/elides" class="toc-entry-anchor">elides</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.tools.analyzer.passes.emit-form">clojure.tools.analyzer.passes.emit-form</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.passes.emit-form/-emit-form*" class="toc-entry-anchor">-emit-form*</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.passes.emit-form/emit-form" class="toc-entry-anchor">emit-form</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.passes.emit-form/emit-hygienic-form" class="toc-entry-anchor">emit-hygienic-form</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.tools.analyzer.passes.index-vector-nodes">clojure.tools.analyzer.passes.index-vector-nodes</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.passes.index-vector-nodes/index-vector-nodes" class="toc-entry-anchor">index-vector-nodes</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.tools.analyzer.passes.source-info">clojure.tools.analyzer.passes.source-info</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.passes.source-info/source-info" class="toc-entry-anchor">source-info</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.tools.analyzer.passes.trim">clojure.tools.analyzer.passes.trim</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.passes.trim/trim" class="toc-entry-anchor">trim</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.tools.analyzer.passes.uniquify">clojure.tools.analyzer.passes.uniquify</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.passes.uniquify/uniquify-locals" class="toc-entry-anchor">uniquify-locals</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.tools.analyzer.passes.warn-earmuff">clojure.tools.analyzer.passes.warn-earmuff</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.passes.warn-earmuff/warn-earmuff" class="toc-entry-anchor">warn-earmuff</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.tools.analyzer.utils">clojure.tools.analyzer.utils</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.utils/-source-info" class="toc-entry-anchor">-source-info</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.utils/arglist-for-arity" class="toc-entry-anchor">arglist-for-arity</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.utils/boolean?" class="toc-entry-anchor">boolean?</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.utils/butlast+last" class="toc-entry-anchor">butlast+last</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.utils/classify" class="toc-entry-anchor">classify</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.utils/const-val" class="toc-entry-anchor">const-val</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.utils/constant?" class="toc-entry-anchor">constant?</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.utils/ctx" class="toc-entry-anchor">ctx</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.utils/dissoc-env" class="toc-entry-anchor">dissoc-env</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.utils/dynamic?" class="toc-entry-anchor">dynamic?</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.utils/into!" class="toc-entry-anchor">into!</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.utils/macro?" class="toc-entry-anchor">macro?</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.utils/mapv'" class="toc-entry-anchor">mapv'</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.utils/merge'" class="toc-entry-anchor">merge'</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.utils/mmerge" class="toc-entry-anchor">mmerge</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.utils/obj?" class="toc-entry-anchor">obj?</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.utils/private?" class="toc-entry-anchor">private?</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.utils/protocol-node?" class="toc-entry-anchor">protocol-node?</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.utils/record?" class="toc-entry-anchor">record?</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.utils/reference?" class="toc-entry-anchor">reference?</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.utils/regex?" class="toc-entry-anchor">regex?</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.utils/resolve-ns" class="toc-entry-anchor">resolve-ns</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.utils/resolve-sym" class="toc-entry-anchor">resolve-sym</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.utils/rseqv" class="toc-entry-anchor">rseqv</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.utils/select-keys'" class="toc-entry-anchor">select-keys'</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.utils/source-info" class="toc-entry-anchor">source-info</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.utils/type?" class="toc-entry-anchor">type?</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.utils/update-keys" class="toc-entry-anchor">update-keys</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.utils/update-kv" class="toc-entry-anchor">update-kv</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.tools.analyzer.utils/update-vals" class="toc-entry-anchor">update-vals</a>
      
    </div>
  </div>
</div>
</div>
                <div id="content-tag"><h1 id="overview">API for <span id="clojure.tools.analyzer">clojure.tools.analyzer</span>
  - <span id="header-project">tools.analyzer</span> <span id="header-version">1.1.2-SNAPSHOT</span><span id="header-status-block"> (<span id="header-status">in development</span>)</span>
  </h1>

<br />Full namespace name: <span id="long-name">clojure.tools.analyzer</span>
<p></p>
<h2>Overview</h2>
<div id="home-page">Project home page is <a href="https://github.com/clojure/tools.analyzer/">https://github.com/clojure/tools.analyzer/</a></div>
<pre id="namespace-docstr">Analyzer for clojure code, host agnostic.

Entry point:
* analyze

Platform implementers must provide dynamic bindings for:
* macroexpand-1
* parse
* create-var
* var?

Setting up the global env is also required, see clojure.tools.analyzer.env

See clojure.tools.analyzer.core-test for an example on how to setup the analyzer.</pre>


<br />



<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer/-parse">-parse</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-parse form env)
</pre>
    <pre id="var-docstr">Takes a form and an env map and dispatches on the head of the form, that is
a special form.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer.clj#L805">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer/analyze">analyze</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (analyze form env)
</pre>
    <pre id="var-docstr">Given a form to analyze and an environment, a map containing:
* :locals     a map from binding symbol to AST of the binding value
* :context    a keyword describing the form's context from the :ctx/* hierarchy.
 ** :ctx/expr      the form is an expression: its value is used
 ** :ctx/return    the form is an expression in return position, derives :ctx/expr
 ** :ctx/statement the value of the form is not used
* :ns         a symbol representing the current namespace of the form to be
              analyzed

returns an AST for that form.

Every node in the AST is a map that is *guaranteed* to have the following keys:
* :op   a keyword describing the AST node
* :form the form represented by the AST node
* :env  the environment map of the AST node

Additionally if the AST node contains sub-nodes, it is guaranteed to have:
* :children a vector of the keys of the AST node mapping to the sub-nodes,
            ordered, when that makes sense

It is considered a node either the top-level node (marked with :top-level true)
or a node that can be reached via :children; if a node contains a node-like
map that is not reachable by :children, there's no guarantee that such a map
will contain the guaranteed keys.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer.clj#L88">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer/analyze-form">analyze-form</h2>
    <span id="var-type">dynamic multimethod</span><br />
    <pre id="var-usage">No usage documentation available</pre>
    <pre id="var-docstr">Like analyze, but does not mark the form with :top-level true</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer.clj#L40">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer/analyze-in-env">analyze-in-env</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (analyze-in-env env)
</pre>
    <pre id="var-docstr">Takes an env map and returns a function that analyzes a form in that env</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer.clj#L124">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer/create-var">create-var</h2>
    <span id="var-type">dynamic function</span><br />
    <pre id="var-usage">Usage: (create-var sym env)
</pre>
    <pre id="var-docstr">Creates a var for sym and returns it</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer.clj#L140">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer/empty-env">empty-env</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (empty-env)
</pre>
    <pre id="var-docstr">Returns an empty env</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer.clj#L117">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer/macroexpand">macroexpand</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (macroexpand form env)
</pre>
    <pre id="var-docstr">Repeatedly calls macroexpand-1 on form until it no longer
represents a macro form, then returns it.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer.clj#L224">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer/macroexpand-1">macroexpand-1</h2>
    <span id="var-type">dynamic function</span><br />
    <pre id="var-usage">Usage: (macroexpand-1 form env)
</pre>
    <pre id="var-docstr">If form represents a macro form, returns its expansion,
else returns form.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer.clj#L129">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer/parse">parse</h2>
    <span id="var-type">dynamic function</span><br />
    <pre id="var-usage">Usage: (parse [op &amp; args] env)
</pre>
    <pre id="var-docstr">Multimethod that dispatches on op, should default to -parse</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer.clj#L135">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer/specials">specials</h2>
    <span id="var-type">var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">Set of special forms common to every clojure variant</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer.clj#L218">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer/var?">var?</h2>
    <span id="var-type">dynamic function</span><br />
    <pre id="var-usage">Usage: (var? obj)
</pre>
    <pre id="var-docstr">Returns true if obj represent a var form as returned by create-var</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer.clj#L145">Source</a>
  </div>
</div>

<br />
<h2 id="clojure.tools.analyzer.ast">clojure.tools.analyzer.ast</h2>
<pre id="namespace-docstr">Utilities for AST walking/updating</pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.ast/ast-&gt;eav">ast-&gt;eav</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (ast-&gt;eav ast)
</pre>
    <pre id="var-docstr">Returns an EAV representation of the current AST that can be used by
Datomic's Datalog.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/17c3995d85b231de2b8f8b260cee30f444f0786e/src/main/clojure/clojure/tools/analyzer/ast.clj#L123">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.ast/children">children</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (children ast)
</pre>
    <pre id="var-docstr">Return a vector of the children expression of the AST node, if it has any.
The children expressions are kept in order and flattened so that the returning
vector contains only nodes and not vectors of nodes.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/17c3995d85b231de2b8f8b260cee30f444f0786e/src/main/clojure/clojure/tools/analyzer/ast.clj#L36">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.ast/children*">children*</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (children* {:keys [children], :as ast})
</pre>
    <pre id="var-docstr">Return a vector of vectors of the children node key and the children expression
of the AST node, if it has any.
The returned vector returns the children in the order as they appear in the
:children field of the AST, and the children expressions may be either a node
or a vector of nodes.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/17c3995d85b231de2b8f8b260cee30f444f0786e/src/main/clojure/clojure/tools/analyzer/ast.clj#L26">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.ast/cycling">cycling</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (cycling &amp; fns*)
</pre>
    <pre id="var-docstr">Combine the given passes in a single pass that will be applied repeatedly
to the AST until applying it another time will have no effect</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/17c3995d85b231de2b8f8b260cee30f444f0786e/src/main/clojure/clojure/tools/analyzer/ast.clj#L14">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.ast/nodes">nodes</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (nodes ast)
</pre>
    <pre id="var-docstr">Returns a lazy-seq of all the nodes in the given AST, in depth-first pre-order.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/17c3995d85b231de2b8f8b260cee30f444f0786e/src/main/clojure/clojure/tools/analyzer/ast.clj#L117">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.ast/postwalk">postwalk</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (postwalk ast f)
       (postwalk ast f reversed?)
</pre>
    <pre id="var-docstr">Shorthand for (walk ast identity f reversed?)</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/17c3995d85b231de2b8f8b260cee30f444f0786e/src/main/clojure/clojure/tools/analyzer/ast.clj#L110">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.ast/prewalk">prewalk</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (prewalk ast f)
</pre>
    <pre id="var-docstr">Shorthand for (walk ast f identity)</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/17c3995d85b231de2b8f8b260cee30f444f0786e/src/main/clojure/clojure/tools/analyzer/ast.clj#L105">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.ast/update-children">update-children</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (update-children ast f)
       (update-children ast f reversed?)
</pre>
    <pre id="var-docstr">Applies `f` to each AST children node, replacing it with the returned value.
If reversed? is not-nil, `pre` and `post` will be applied starting from the last
children of the AST node to the first one.
Short-circuits on reduced.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/17c3995d85b231de2b8f8b260cee30f444f0786e/src/main/clojure/clojure/tools/analyzer/ast.clj#L75">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.ast/update-children-reduced">update-children-reduced</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (update-children-reduced ast f)
       (update-children-reduced ast f reversed?)
</pre>
    <pre id="var-docstr">Like update-children but returns a reduced holding the AST if f short-circuited.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/17c3995d85b231de2b8f8b260cee30f444f0786e/src/main/clojure/clojure/tools/analyzer/ast.clj#L58">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.ast/walk">walk</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (walk ast pre post)
       (walk ast pre post reversed?)
</pre>
    <pre id="var-docstr">Walk the ast applying `pre` when entering the nodes, and `post` when exiting.
Both functions must return a valid node since the returned value will replace
the node in the AST which was given as input to the function.
If reversed? is not-nil, `pre` and `post` will be applied starting from the last
children of the AST node to the first one.
Short-circuits on reduced.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/17c3995d85b231de2b8f8b260cee30f444f0786e/src/main/clojure/clojure/tools/analyzer/ast.clj#L84">Source</a>
  </div>
</div>

<br />
<h2 id="clojure.tools.analyzer.ast.query">clojure.tools.analyzer.ast.query</h2>
<pre id="namespace-docstr">Utilities for querying tools.analyzer ASTs with Datomic</pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.ast.query/db">db</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (db asts)
</pre>
    <pre id="var-docstr">Given a list of ASTs, returns a representation of those
that can be used as a database in a Datomic Datalog query.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/17c3995d85b231de2b8f8b260cee30f444f0786e/src/main/clojure/clojure/tools/analyzer/ast/query.clj#L74">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.ast.query/q">q</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (q query asts &amp; inputs)
</pre>
    <pre id="var-docstr">Execute a Datomic Datalog query against the ASTs.
The first input is always assumed to be an AST database, if more
are required, it's required to call `db` on them.
`unfold-expression-clauses` is automatically applied to the
query.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/17c3995d85b231de2b8f8b260cee30f444f0786e/src/main/clojure/clojure/tools/analyzer/ast/query.clj#L80">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.ast.query/query-map">query-map</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (query-map query)
</pre>
    <pre id="var-docstr">Transforms a Datomic query from its vector representation to its map one.
If the given query is already in its map representation, the original query
is returned.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/17c3995d85b231de2b8f8b260cee30f444f0786e/src/main/clojure/clojure/tools/analyzer/ast/query.clj#L14">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.ast.query/resolve-calls">resolve-calls</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (resolve-calls query)
</pre>
    <pre id="var-docstr">Automatically replace fn name symbols in expression clauses with
their namespace qualified one if the symbol can be resolved in the
current namespace.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/17c3995d85b231de2b8f8b260cee30f444f0786e/src/main/clojure/clojure/tools/analyzer/ast/query.clj#L56">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.ast.query/unfold-expression-clauses">unfold-expression-clauses</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (unfold-expression-clauses query)
</pre>
    <pre id="var-docstr">Given a Datomic query, walk the :where clauses searching for
expression clauses with nested calls, unnesting those calls.

E.g {:where [[(inc (dec ?foo)) ?bar] ..] ..} will be transformed into
{:where [[(dec ?foo) ?1234] [(inc ?1234) ?bar] ..] ..}</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/17c3995d85b231de2b8f8b260cee30f444f0786e/src/main/clojure/clojure/tools/analyzer/ast/query.clj#L28">Source</a>
  </div>
</div>

<br />
<h2 id="clojure.tools.analyzer.env">clojure.tools.analyzer.env</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.env/*env*">*env*</h2>
    <span id="var-type">dynamic var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">Global env atom containing a map.
Required options:
 * :namespaces a map from namespace symbol to namespace map,
   the namespace map contains at least the following keys:
  ** :mappings a map of mappings of the namespace, symbol to var/class
  ** :aliases a map of the aliases of the namespace, symbol to symbol
  ** :ns a symbol representing the namespace</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/17c3995d85b231de2b8f8b260cee30f444f0786e/src/main/clojure/clojure/tools/analyzer/env.clj#L12">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.env/deref-env">deref-env</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (deref-env)
</pre>
    <pre id="var-docstr">Returns the value of the current global env if bound, otherwise
throws an exception.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/17c3995d85b231de2b8f8b260cee30f444f0786e/src/main/clojure/clojure/tools/analyzer/env.clj#L44">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.env/ensure">ensure</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ensure env &amp; body)
</pre>
    <pre id="var-docstr">If *env* is not bound it binds it to env before executing the body</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/17c3995d85b231de2b8f8b260cee30f444f0786e/src/main/clojure/clojure/tools/analyzer/env.clj#L36">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.env/with-env">with-env</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (with-env env &amp; body)
</pre>
    <pre id="var-docstr">Binds the global env to env, then executes the body</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/17c3995d85b231de2b8f8b260cee30f444f0786e/src/main/clojure/clojure/tools/analyzer/env.clj#L22">Source</a>
  </div>
</div>

<br />
<h2 id="clojure.tools.analyzer.passes">clojure.tools.analyzer.passes</h2>
<pre id="namespace-docstr">Utilities for pass scheduling</pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.passes/calculate-deps">calculate-deps</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (calculate-deps passes)
</pre>
    <pre id="var-docstr">Takes a map of pass-name -&gt; pass-info and adds to each pass-info :dependencies and
:dependants info, which also contains the transitive dependencies</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer/passes.clj#L47">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.passes/desugar-deps">desugar-deps</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (desugar-deps passes)
</pre>
    <pre id="var-docstr">Takes a map of pass-name -&gt; pass deps and puts the :after :affects and :before passes
in the appropriate pass :depends</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer/passes.clj#L25">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.passes/group">group</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (group state)
</pre>
    <pre id="var-docstr">Takes a scheduler state and returns a vector of three elements (or nil):
* the :walk of the current group
* a vector of consecutive passes that can be collapsed in a single pass (the current group)
* the remaining scheduler state

E.g. given:
[{:walk :any ..} {:walk :pre ..} {:walk :post ..} {:walk :pre ..}]
it will return:
[:pre [{:walk :any ..} {:walk :pre ..}] [{:walk :post ..} {:walk :pre ..}]]</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer/passes.clj#L62">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.passes/schedule">schedule</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (schedule passes &amp; [opts])
</pre>
    <pre id="var-docstr">Takes a set of Vars that represent tools.analyzer passes and returns a function
that takes an AST and applies all the passes and their dependencies to the AST,
trying to compose together as many passes as possible to reduce the number of
full tree traversals.

Each pass must have a :pass-info element in its Var's metadata and it must point
to a map with the following parameters (:before, :after, :affects and :state are
optional):
* :after    a set of Vars, the passes that must be run before this pass
* :before   a set of Vars, the passes that must be run after this pass
* :depends  a set of Vars, the passes this pass depends on, implies :after
* :walk     a keyword, one of:
              - :none if the pass does its own tree walking and cannot be composed
                      with other passes
              - :post if the pass requires a postwalk and can be composed with other
                      passes
              - :pre  if the pass requires a prewalk and can be composed with other
                      passes
              - :any  if the pass can be composed with other passes in both a prewalk
                      or a postwalk
* :affects  a set of Vars, this pass must be the last in the same tree traversal that all
            the specified passes must participate in
            This pass must take a function as argument and return the actual pass, the
            argument represents the reified tree traversal which the pass can use to
            control a recursive traversal, implies :depends
* :state    a no-arg function that should return an atom holding an init value that will be
            passed as the first argument to the pass (the pass will thus take the ast
            as the second parameter), the atom will be the same for the whole tree traversal
            and thus can be used to preserve state across the traversal
An opts map might be provided, valid parameters:
* :debug?   if true, returns a vector of the scheduled passes rather than the concrete
            function</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer/passes.clj#L173">Source</a>
  </div>
</div>

<br />
<h2 id="clojure.tools.analyzer.passes.add-binding-atom">clojure.tools.analyzer.passes.add-binding-atom</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.passes.add-binding-atom/add-binding-atom">add-binding-atom</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (add-binding-atom ast)
       (add-binding-atom state ast)
</pre>
    <pre id="var-docstr">Adds an atom-backed-map to every local binding,the same
atom will be shared between all occurences of that local.

The atom is put in the :atom field of the node.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/00e9d46c56ebbbcb0f9c62ed6d966ecc38a99a9d/src/main/clojure/clojure/tools/analyzer/passes/add_binding_atom.clj#L13">Source</a>
  </div>
</div>

<br />
<h2 id="clojure.tools.analyzer.passes.collect-closed-overs">clojure.tools.analyzer.passes.collect-closed-overs</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.passes.collect-closed-overs/collect-closed-overs">collect-closed-overs</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (collect-closed-overs ast)
</pre>
    <pre id="var-docstr">Attach closed-overs info to the AST as specified by the passes opts:
* :where       set of :op nodes where to attach the closed-overs
* :top-level?  if true attach closed-overs info to the top-level node

The info will be attached in the :closed-overs field of the AST node
and will be a map of local name -&gt; binding AST node</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/b17311c9e2ef1700563665f8647e48c571f85011/src/main/clojure/clojure/tools/analyzer/passes/collect_closed_overs.clj#L59">Source</a>
  </div>
</div>

<br />
<h2 id="clojure.tools.analyzer.passes.constant-lifter">clojure.tools.analyzer.passes.constant-lifter</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.passes.constant-lifter/constant-lift">constant-lift</h2>
    <span id="var-type">multimethod</span><br />
    <pre id="var-usage">No usage documentation available</pre>
    <pre id="var-docstr">If the node represents a collection with no metadata, and every item of that
collection is a literal, transform the node to an equivalent :const node.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/5dc7857ee354d99b012e32dc4890161800200493/src/main/clojure/clojure/tools/analyzer/passes/constant_lifter.clj#L12">Source</a>
  </div>
</div>

<br />
<h2 id="clojure.tools.analyzer.passes.elide-meta">clojure.tools.analyzer.passes.elide-meta</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.passes.elide-meta/elide-meta">elide-meta</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (elide-meta ast)
</pre>
    <pre id="var-docstr">If elides is not empty and the AST node contains metadata,
dissoc all the keys in elides from the metadata.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/0516951623904f810839514dd328ebe97dd7cc54/src/main/clojure/clojure/tools/analyzer/passes/elide_meta.clj#L82">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.passes.elide-meta/elides">elides</h2>
    <span id="var-type">dynamic var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">A map of op keywords to predicate IFns.
The predicate will be used to indicate what map keys should be elided on
metadata of nodes for that op.
:all can be used to indicate what should be elided for every node with
metadata.
Defaults to {:all (set (:elide-meta *compiler-options*))}</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/0516951623904f810839514dd328ebe97dd7cc54/src/main/clojure/clojure/tools/analyzer/passes/elide_meta.clj#L12">Source</a>
  </div>
</div>

<br />
<h2 id="clojure.tools.analyzer.passes.emit-form">clojure.tools.analyzer.passes.emit-form</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.passes.emit-form/-emit-form*">-emit-form*</h2>
    <span id="var-type">dynamic function</span><br />
    <pre id="var-usage">Usage: (-emit-form* {:keys [form], :as ast} opts)
</pre>
    <pre id="var-docstr">Extension point for custom emit-form implementations, should be rebound
to a multimethod with custom emit-form :opts.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/88b74a22c4a62b716aa7dd587539aea257bfa3c0/src/main/clojure/clojure/tools/analyzer/passes/emit_form.clj#L14">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.passes.emit-form/emit-form">emit-form</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (emit-form ast)
       (emit-form ast opts)
</pre>
    <pre id="var-docstr">Return the form represented by the given AST.
Opts is a set of options, valid options are:
 * :hygienic</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/88b74a22c4a62b716aa7dd587539aea257bfa3c0/src/main/clojure/clojure/tools/analyzer/passes/emit_form.clj#L24">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.passes.emit-form/emit-hygienic-form">emit-hygienic-form</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (emit-hygienic-form ast)
</pre>
    <pre id="var-docstr">Return an hygienic form represented by the given AST</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/88b74a22c4a62b716aa7dd587539aea257bfa3c0/src/main/clojure/clojure/tools/analyzer/passes/emit_form.clj#L32">Source</a>
  </div>
</div>

<br />
<h2 id="clojure.tools.analyzer.passes.index-vector-nodes">clojure.tools.analyzer.passes.index-vector-nodes</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.passes.index-vector-nodes/index-vector-nodes">index-vector-nodes</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (index-vector-nodes ast)
</pre>
    <pre id="var-docstr">Adds an :idx attribute to nodes in a vector children, representing the position
of the node vector.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/35086cdeb46b239f0d2e086db0813a408e9e4e02/src/main/clojure/clojure/tools/analyzer/passes/index_vector_nodes.clj#L11">Source</a>
  </div>
</div>

<br />
<h2 id="clojure.tools.analyzer.passes.source-info">clojure.tools.analyzer.passes.source-info</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.passes.source-info/source-info">source-info</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (source-info ast)
</pre>
    <pre id="var-docstr">Adds (when avaliable) :line, :column, :end-line, :end-column and :file info to the AST :env</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/88e3d8ca1e3b94cd8961d6993afa607d35097d34/src/main/clojure/clojure/tools/analyzer/passes/source_info.clj#L17">Source</a>
  </div>
</div>

<br />
<h2 id="clojure.tools.analyzer.passes.trim">clojure.tools.analyzer.passes.trim</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.passes.trim/trim">trim</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (trim ast)
</pre>
    <pre id="var-docstr">Trims the AST of unnecessary nodes, e.g. (do (do 1)) -&gt; 1</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/8a95cd2cfc1abf7a48caf52c3871b61453427e76/src/main/clojure/clojure/tools/analyzer/passes/trim.clj#L46">Source</a>
  </div>
</div>

<br />
<h2 id="clojure.tools.analyzer.passes.uniquify">clojure.tools.analyzer.passes.uniquify</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.passes.uniquify/uniquify-locals">uniquify-locals</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (uniquify-locals ast)
</pre>
    <pre id="var-docstr">Walks the AST performing alpha-conversion on the :name field
 of :local/:binding nodes, invalidates :local map in :env field

Passes opts:
* :uniquify/uniquify-env  If true, uniquifies the :env :locals map</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer/passes/uniquify.clj#L86">Source</a>
  </div>
</div>

<br />
<h2 id="clojure.tools.analyzer.passes.warn-earmuff">clojure.tools.analyzer.passes.warn-earmuff</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.passes.warn-earmuff/warn-earmuff">warn-earmuff</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (warn-earmuff ast)
</pre>
    <pre id="var-docstr">Prints a warning to *err* if the AST node is a :def node and the
var name contains earmuffs but the var is not marked dynamic</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/268aa68e79e5dd9dad036d134991d0b5d803cb57/src/main/clojure/clojure/tools/analyzer/passes/warn_earmuff.clj#L12">Source</a>
  </div>
</div>

<br />
<h2 id="clojure.tools.analyzer.utils">clojure.tools.analyzer.utils</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/-source-info">-source-info</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-source-info x env)
</pre>
    <pre id="var-docstr">Returns the source-info of x</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer/utils.clj#L220">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/arglist-for-arity">arglist-for-arity</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (arglist-for-arity fn argc)
</pre>
    <pre id="var-docstr">Takes a fn node and an argc and returns the matching arglist</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer/utils.clj#L174">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/boolean?">boolean?</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (boolean? x)
</pre>
    <pre id="var-docstr">Returns true if x is a boolean</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer/utils.clj#L96">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/butlast+last">butlast+last</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (butlast+last s)
</pre>
    <pre id="var-docstr">Returns same value as (juxt butlast last), but slightly more
efficient since it only traverses the input sequence s once, not
twice.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer/utils.clj#L35">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/classify">classify</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (classify form)
</pre>
    <pre id="var-docstr">Returns a keyword describing the form type</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer/utils.clj#L101">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/const-val">const-val</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (const-val {:keys [form val]})
</pre>
    <pre id="var-docstr">Returns the value of a constant node (either :quote or :const)</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer/utils.clj#L229">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/constant?">constant?</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (constant? var)
       (constant? var m)
</pre>
    <pre id="var-docstr">Returns true if the var is a const</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer/utils.clj#L135">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/ctx">ctx</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (ctx env ctx)
</pre>
    <pre id="var-docstr">Returns a copy of the passed environment with :context set to ctx</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer/utils.clj#L25">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/dissoc-env">dissoc-env</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (dissoc-env ast)
</pre>
    <pre id="var-docstr">Dissocs :env from the ast</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer/utils.clj#L30">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/dynamic?">dynamic?</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (dynamic? var)
       (dynamic? var m)
</pre>
    <pre id="var-docstr">Returns true if the var is dynamic</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer/utils.clj#L141">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/into!">into!</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (into! to from)
</pre>
    <pre id="var-docstr">Like into, but for transients</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer/utils.clj#L15">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/macro?">macro?</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (macro? var)
       (macro? var m)
</pre>
    <pre id="var-docstr">Returns true if the var maps to a macro</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer/utils.clj#L129">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/mapv'">mapv'</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (mapv' f v)
</pre>
    <pre id="var-docstr">Like mapv, but short-circuits on reduced</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer/utils.clj#L202">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/merge'">merge'</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (merge' m &amp; mms)
</pre>
    <pre id="var-docstr">Like merge, but uses transients</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer/utils.clj#L197">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/mmerge">mmerge</h2>
    <span id="var-type">var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">Same as (fn [m1 m2] (merge-with merge m2 m1))</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer/utils.clj#L234">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/obj?">obj?</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (obj? x)
</pre>
    <pre id="var-docstr">Returns true if x implements IObj</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer/utils.clj#L71">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/private?">private?</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (private? var)
       (private? var m)
</pre>
    <pre id="var-docstr">Returns true if the var is private</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer/utils.clj#L123">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/protocol-node?">protocol-node?</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (protocol-node? var)
       (protocol-node? var m)
</pre>
    <pre id="var-docstr">Returns true if the var maps to a protocol function</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer/utils.clj#L149">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/record?">record?</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (record? x)
</pre>
    <pre id="var-docstr">Returns true if x is a record</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer/utils.clj#L61">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/reference?">reference?</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (reference? x)
</pre>
    <pre id="var-docstr">Returns true if x implements IReference</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer/utils.clj#L76">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/regex?">regex?</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (regex? x)
</pre>
    <pre id="var-docstr">Returns true if x is a regex</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer/utils.clj#L88">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/resolve-ns">resolve-ns</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (resolve-ns ns-sym {:keys [ns]})
</pre>
    <pre id="var-docstr">Resolves the ns mapped by the given sym in the global env</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer/utils.clj#L155">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/resolve-sym">resolve-sym</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (resolve-sym sym {:keys [ns], :as env})
</pre>
    <pre id="var-docstr">Resolves the value mapped by the given sym in the global env</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer/utils.clj#L163">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/rseqv">rseqv</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (rseqv v)
</pre>
    <pre id="var-docstr">Same as (comp vec rseq)</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer/utils.clj#L20">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/select-keys'">select-keys'</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (select-keys' map keyseq)
</pre>
    <pre id="var-docstr">Like clojure.core/select-keys, but uses transients and doesn't preserve meta</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer/utils.clj#L185">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/source-info">source-info</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (source-info m)
</pre>
    <pre id="var-docstr">Returns the available source-info keys from a map</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer/utils.clj#L214">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/type?">type?</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (type? x)
</pre>
    <pre id="var-docstr">Returns true if x is a type</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer/utils.clj#L66">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/update-keys">update-keys</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (update-keys m f)
</pre>
    <pre id="var-docstr">Applies f to all the keys in the map</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer/utils.clj#L51">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/update-kv">update-kv</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (update-kv m f)
</pre>
    <pre id="var-docstr">Applies f to all the keys and vals in the map</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer/utils.clj#L56">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.tools.analyzer.utils/update-vals">update-vals</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (update-vals m f)
</pre>
    <pre id="var-docstr">Applies f to all the vals in the map</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/tools.analyzer/blob/599274104faad08f31607063ac8d7540f9e30af6/src/main/clojure/clojure/tools/analyzer/utils.clj#L46">Source</a>
  </div>
</div>


</div>
              </div>
            </div>
          </div>
	</div>
	<div id="foot">
	  <div id="copyright" style="text-align: center;">Copyright 2007-2023 by Rich Hickey and the various contributors</div>
	</div>
      </div>
      <div id="DesignedBy">Logo &amp; site design by <a href="http://www.tomhickey.com" title="Visit Tom Hickey's website.">Tom Hickey</a>.<br />
      Clojure auto-documentation system by Tom Faulhaber.</div>
    </div>
    <!-- /AllContentContainer -->
  </body>

</html>